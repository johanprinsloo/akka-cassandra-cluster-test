kamon {
metrics {

    # Time interval for collecting all metrics and send the snapshots to all subscribed actors.
    tick-interval = 1 second

    # Time interval for recording values on all registered gauges.
    gauge-recording-interval = 100 milliseconds


    # Default size for the LongBuffer that gets allocated for metrics collection and merge. The
    # value should correspond to the highest number of different buckets with values that might
    # exist in a single histogram during a metrics collection. The default value of 33792 is a
    # very conservative value and its equal to the total number of buckets required to cover values
    # from 1 nanosecond to 1 hour with 0.1% precision (3 significant value digits). That means
    # that would need to have at least one measurement on every bucket of a single histogram to
    # fully utilize this buffer, which is *really* unlikely to ever happen. Since the buffer should
    # be allocated once and reused it shouldn't impose a memory footprint issue.
    default-collection-context-buffer-size = 33792

    # Disables a big error message that will be typically logged if your application wasn't started
    # with the -javaagent:/path-to-aspectj-weaver.jar option. If you are only using KamonStandalone
    # it might be ok for you to turn this error off.
    disable-aspectj-weaver-missing-error = false


    dispatchers {

      # Dispatcher for periodical gauge value recordings.
      gauge-recordings = ${kamon.default-dispatcher}

      # Dispatcher for subscriptions and metrics collection actors.
      metric-subscriptions = ${kamon.default-dispatcher}
    }


    filters = [
      {
        actor {
          includes = []
          excludes = [ "system/*", "user/IO-*" ]
        }
      },
      {
        trace {
          includes = [ "*" ]
          excludes = []
        }
      },
      {
        dispatcher {
          includes = [ "*" ]
          excludes = []
        }
      }
    ]

    precision {
      default-histogram-precision {
        highest-trackable-value = 3600000000000
        significant-value-digits = 2
      }

      default-min-max-counter-precision {
        refresh-interval = 100 milliseconds
        highest-trackable-value = 999999999
        significant-value-digits = 2
      }

      default-gauge-precision {
        refresh-interval = 100 milliseconds
        highest-trackable-value = 999999999
        significant-value-digits = 2
      }


      actor {
        processing-time = ${kamon.metrics.precision.default-histogram-precision}
        time-in-mailbox = ${kamon.metrics.precision.default-histogram-precision}
        mailbox-size = ${kamon.metrics.precision.default-min-max-counter-precision}
      }

      trace {
        elapsed-time = ${kamon.metrics.precision.default-histogram-precision}
        segment = ${kamon.metrics.precision.default-histogram-precision}
      }

      dispatcher {
        maximum-pool-size {
          highest-trackable-value = 999999999
          significant-value-digits = 2
        }
        running-thread-count {
          highest-trackable-value = 999999999
          significant-value-digits = 2
        }
        queued-task-count {
          highest-trackable-value = 999999999
          significant-value-digits = 2
        }
        pool-size {
          highest-trackable-value = 999999999
          significant-value-digits = 2
        }
      }
    }
  }

  trace {

    # If ask-pattern-tracing is enabled, a WARN level log message will be generated if a future generated by the `ask`
    # pattern fails with a `AskTimeoutException` and the log message will contain a stack trace captured at the moment
    # the future was created.
    ask-pattern-tracing = off
  }

  weaver {

    # AspectJ options supported by LTW
    # showWeaveInfo: show informational messages whenever the weaver touches a class file.
    # verbose: show informational messages about the weaving process.
    # debug: show a messages for each class passed to the weaver indicating whether it was woven, excluded or ignored.
    # showWarn: show warning messages about the weaving process.

    showWeaveInfo = off
    verbose = off
    debug = off
    showWarn = off
  }

  spray {
    # Header name used when propagating the `TraceContext.token` value across applications.
    trace-token-header-name = "X-Trace-Token"

    # When set to true, Kamon will automatically set and propogate the `TraceContext.token` value under the following
    # conditions:
    #  - When a server side request is received containing the trace token header, the new `TraceContext` will have that
    #    some token, and once the response to that request is ready, the trace token header is also included in the
    #    response.
    #  - When a spray-client request is issued and a `TraceContext` is available, the trace token header will be included
    #    in the `HttpRequest` headers.
    automatic-trace-token-propagation = true


    client {
      # Strategy used for automatic trace segment generation when issue requests with spray-client. The possible values
      # are:
      #  - pipelining: measures the time during which the user application code is waiting for a spray-client request to
      #    complete, by attaching a callback to the Future[HttpResponse] returned by `spray.client.pipelining.sendReceive`.
      #    If `spray.client.pipelining.sendReceive` is not used, the segment measurement wont be performed.
      #  - internal: measures the internal time taken by spray-client to finish a request. Sometimes the user application
      #    code has a finite future timeout (like when using `spray.client.pipelining.sendReceive`) that doesn't match
      #    the actual amount of time spray might take internally to resolve a request, counting retries, redirects,
      #    connection timeouts and so on. If using the internal strategy, the measured time will include the entire time
      #    since the request has been received by the corresponding `HttpHostConnector` until a response is sent back
      #    to the requester.
      segment-collection-strategy = pipelining
    }
  }
  statsd {
    # Hostname and port in which your StatsD is running. Remember that StatsD packets are sent using UDP and
    # setting unreachable hosts and/or not open ports wont be warned by the Kamon, your data wont go anywhere.
    hostname = "10.5.151.182"
    port = 8125

    # Interval between metrics data flushes to StatsD. It's value must be equal or greater than the
    # kamon.metrics.tick-interval setting.
    flush-interval = 1 second

    # Max packet size for UDP metrics data sent to StatsD.
    max-packet-size = 1024 bytes

    # Subscription patterns used to select which metrics will be pushed to StatsD. Note that first, metrics
    # collection for your desired entities must be activated under the kamon.metrics.filters settings.
    includes {
      actor       = [ "*" ]
      trace       = [ "*" ]
      dispatcher  = [ "*" ]
    }

    simple-metric-key-generator {
      # Application prefix for all metrics pushed to StatsD. The default namespacing scheme for metrics follows
      # this pattern:
      #    application.host.entity.entity-name.metric-name
      application = "kamon"
    }
  }
}
